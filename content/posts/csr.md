---
title: "CSR（Client-Side Rendering）彻底讲透：架构、策略与实战避坑"
date: "2025-12-26"
slug: "csr"
category: "frontend"
tags: ["csr", "incremental-static-regeneration", "nextjs", "ssg", "ssr", "cdn"]
excerpt: "CSR 不是“把页面提前渲染一下”，而是一整套围绕 浏览器里的 JavaScript 渲染 + 路由/状态管理 + 数据获取 的架构。"
draft: false
featured: false
pinned: false
---
下面我把 **CSR（Client-Side Rendering，客户端渲染）讲到“你真的懂”的程度：从它到底是什么**、**浏览器里发生了什么**、**为什么会快/慢**、**怎么设计架构**、**怎么做性能与工程落地**、**怎么排错与验证**，给你一套完整心智模型。

---

# 1）CSR 到底是什么（架构定义）
**CSR = 页面主要内容由浏览器里的 JavaScript 生成并更新。**

更精确地说：

+ 服务器第一次返回的 HTML 通常只包含一个“容器壳”（例如 `<div id="root"></div>`）和指向 JS/CSS 的链接
+ 浏览器下载并执行 JS 后：
    - 创建组件树 / 计算 UI
    - 拉取数据（fetch）
    - 把内容渲染到 DOM
    - 后续交互都由客户端路由和状态更新驱动

你可以把 CSR 看成一个“**在浏览器里运行的应用程序**”（App），网页只是它的容器。

---

# 2）CSR 的完整运行流水线（你必须能背出“发生了什么”）
假设你访问 `https://example.com/products/123`，典型 CSR 的事件顺序是：

## 2.1 网络与解析阶段
1. 浏览器请求 HTML（通常很小）
2. 浏览器解析 HTML，构建 DOM（此时页面可能几乎空白或只有 skeleton）
3. 浏览器发现 `<link rel="stylesheet">`、`<script src="...">`，开始下载 CSS/JS
4. CSS 下载解析，页面有基本样式
5. JS 下载完成，开始执行（这一步是 CSR 的关键瓶颈点）

## 2.2 应用启动阶段（Bootstrap）
6. JS 初始化运行：加载框架 runtime、路由、状态管理、插件等
7. 执行 `createRoot(...).render(<App />)`（或 Vue 的 `createApp`）
8. React/Vue 计算 UI，生成 DOM 更新（首次 render）

## 2.3 数据获取阶段（Data Fetch）
9. 页面组件发起请求：`fetch('/api/products/123')`
10. 等数据返回后更新状态
11. 触发二次渲染，填充真实内容（替换 skeleton）

## 2.4 后续交互阶段
12. 用户点击/输入 → 事件处理 → setState → 重新渲染局部区域
13. 切路由多发生在客户端：不会重新请求整页 HTML（SPA 体验）

> **CSR 的核心：首屏“内容出现”的关键路径=JS 下载+执行+取数。**  
这也是 CSR 性能的“根”。
>

---

# 3）CSR 的优势：为什么它在很多场景是最正确的选择
## 3.1 强交互体验（像 App 一样）
+ 路由切换快（不刷新整页）
+ 状态在客户端持续存在（例如表单编辑、草稿、复杂编辑器）
+ 更容易做复杂交互：拖拽、实时过滤、图表联动、WebSocket 实时数据

## 3.2 服务端成本低、部署简单
+ 服务器只负责静态文件（CDN 托管就能跑）
+ 前后端解耦：API 与前端独立演进

## 3.3 前端工程化优势
+ 统一前端技术栈与组件体系
+ 更容易在客户端做缓存、离线、预取等增强

**典型适用场景**

+ 后台管理系统、仪表盘
+ 富文本/图形编辑器
+ 登录后应用（SEO 不重要）
+ 实时协作/聊天类 Web App

---

# 4）CSR 的代价：它为什么经常“首屏慢、白屏、SEO 弱”
## 4.1 首屏慢的“物理原因”
CSR 首屏内容要出现，通常必须经历：

1. JS 下载完
2. JS 执行完（框架初始化 + 首屏渲染）
3. 数据请求完成（多数业务页面依赖数据）

所以 CSR 首屏常见现象：

+ **白屏时间**（HTML 只有壳，内容需要 JS）
+ **LCP 被 JS 与数据拖累**
+ 低端机或弱网下体验明显变差

## 4.2 SEO 与分享预览弱的原因
如果 HTML 源码里没有正文内容：

+ 搜索引擎可能抓不到（现代爬虫能跑 JS 但成本高、时机不稳定）
+ 社交分享预览（OG tags）可能缺失或不准确

## 4.3 性能瓶颈集中在“主线程”
+ 大 bundle + hydration（如果你还做了 SSR 才有 hydration；纯 CSR 没 hydration，但也有首次 render 成本）
+ 首次渲染 + 解析 + 大量组件 mount
+ 取数后重渲染

---

# 5）CSR 架构设计：你必须把 CSR 做成“快启动、渐进显示、可缓存”的应用
下面是 CSR 做对/做错的分水岭。

## 5.1 首屏策略：App Shell + Skeleton
**App Shell**：把导航框架、布局骨架尽快渲染出来  
**Skeleton**：内容区先用骨架占位，数据回来替换

为什么有效？

+ 用户更早看到“结构”，感知更快
+ 避免 CLS（布局抖动）

怎么做：

+ 首页/入口页尽量轻
+ skeleton 与真实内容保持尺寸一致

## 5.2 数据策略：避免瀑布、避免重复、缓存优先
CSR 最常见的性能杀手是“组件各自 fetch 导致瀑布”。

正确策略：

+ 路由级数据加载（进入路由先并行取数据）
+ 组件只消费数据，不各自拉取（或必须拉取时也要可缓存）
+ 缓存 + SWR：先用缓存渲染，再后台更新

工程落地：

+ 把请求封装成“数据层”（哪怕你不用专门库，也要集中管理）
+ 处理竞态：只接受最新请求结果（AbortController 或序号）

## 5.3 包体策略：代码分割是 CSR 的生命线
CSR 的首屏 JS 越大越慢，这是硬规律。

必须做：

+ 路由级懒加载（动态 import）
+ 大组件懒加载（图表、编辑器、富文本、地图）
+ 第三方库按需引入（别整包 import）

进阶做：

+ 预取下一路由（用户 hover/空闲时）
+ 分离 vendor chunk（提升缓存命中，但别过度拆碎）

## 5.4 客户端路由：状态与 URL 的边界要清晰
在 CSR 中，URL 是重要状态来源：

+ 筛选、分页、搜索词放 URL（可分享、可回退）
+ 临时 UI 状态（弹窗开关）放组件 state
+ 全局业务状态（用户信息、权限、购物车）放 store

做对体现：

+ 回退/刷新不丢关键状态
+ 分享链接能复现当前视图

---

# 6）CSR 性能优化全景：你要按“影响最大→最小”的顺序做
### 第一优先级：减少首屏 JS（最有效）
+ 删除不用的依赖
+ 路由分包 + 懒加载
+ 避免把所有页面逻辑打进入口

### 第二优先级：减少主线程阻塞
+ 大计算放 Web Worker
+ 列表虚拟化（几千行表格必做）
+ 事件处理做节流/防抖，避免长任务

### 第三优先级：更快拿到数据
+ 并行请求、批量接口（BFF 聚合）
+ 接口缓存、CDN（公共数据）
+ 预取（用户即将进入的页面）

### 第四优先级：资源与渲染细节
+ 图片优化（尺寸、格式、懒加载）
+ 关键 CSS 与字体策略
+ 避免 CLS（固定尺寸、骨架一致）

---

# 7）CSR 的“工程落地清单”（真正能用来做项目）
## 7.1 一个合格 CSR 项目至少要有
+ 入口足够轻（首屏不引入全量业务）
+ 路由懒加载
+ 数据层统一封装（错误、重试、取消、缓存）
+ 全局错误边界（白屏兜底）
+ 性能度量（至少能看到 LCP/INP、bundle 体积）
+ 发布缓存策略（静态资源 hash + 长缓存；HTML 短缓存）

## 7.2 CSR 最容易翻车的 6 个坑
1. 入口 import 了所有页面 → 首屏包爆炸
2. 组件各自 fetch → 请求瀑布 + loading 满天飞
3. 列表不虚拟化 → 一滚就卡
4. 大对象/函数 props 不稳定 → 子组件疯狂重渲染
5. localStorage 同步读写太大 → 首次启动卡顿
6. 发版缓存错配 → 旧 HTML 指向新 JS 失败（白屏）

---

# 8）CSR 如何验证“我做对了”（你必须用证据闭环）
你要用这些证据来判断 CSR 架构与优化是否成功：

## 8.1 关键指标（看得见的结果）
+ **LCP**：首屏内容出现时间（CSR 通常更难压）
+ **INP**：交互响应（大 JS/长任务会毁掉）
+ **JS bundle 大小**：入口 chunk、首屏路由 chunk
+ **主线程长任务**：Performance 面板里 >50ms 的任务数量

## 8.2 DevTools 具体看哪里
+ Network：首屏 JS 是否太大、是否并行、是否有瀑布
+ Performance：首次加载期间 JS 执行是否占满主线程
+ Coverage：哪些 JS 实际没用（删依赖/拆分依据）
+ Lighthouse：诊断建议（但别迷信分数，要结合业务）

---

# 9）CSR 与 SSR/SSG 的边界：你什么时候应该“别硬 CSR”
你应该考虑混合或换模式的信号：

+ 你非常需要 SEO/分享预览（内容站、电商详情）
+ 首屏内容必须极快出现（营销页、投放页）
+ 用户设备普遍较弱/网络差（JS 成本更敏感）
+ 你的首屏依赖很多数据且渲染重（CSR 会更吃亏）

常见解法是**混合**：

+ 主体 SSR/SSG，交互岛 CSR（Islands）
+ 或 SSR 首屏 + CSR 作为后续导航体验

---

# 10）一句话总结 CSR 的“正确姿势”
**CSR 不是不能快，它需要你把它当成“应用启动优化”问题：让首屏 JS 更小、数据更少瀑布、渲染更渐进、缓存更有效。**

---

如果你愿意，我可以拿你项目里一个典型页面（比如：后台列表页/仪表盘/搜索页）按 CSR 给你做一份“**首屏关键路径拆解**”：

+ 首屏需要哪些 JS chunk？
+ 哪些请求是瀑布？怎么并行/聚合？
+ 哪些组件导致长任务？怎么拆/虚拟化/worker？  
你只要描述页面结构和交互（不需要贴代码）。

