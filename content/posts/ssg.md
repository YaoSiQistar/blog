---

title: "SSG（Static Site Generation，静态站点生成）彻底讲透：架构、策略与实战避坑"
date: "2025-12-26"
slug: "ssg"
category: "frontend"
tags: ["isr", "incremental-static-regeneration", "nextjs", "ssg", "ssr", "cdn"]
excerpt: "SSG 不是“把页面提前渲染一下”，而是一整套围绕 **构建时渲染 + CDN 缓存 + 内容生产/发布链路** 的架构。"
draft: false
featured: false
pinned: false
---
下面我把 SSG（Static Site Generation，静态站点生成）讲到你“能独立做架构决策、能落地、能排坑”的程度。你会看到：SSG 不是“把页面提前渲染一下”，而是一整套围绕 **构建时渲染 + CDN 缓存 + 内容生产/发布链路** 的架构。

---

# 1）SSG 到底是什么（架构定义）
**SSG = 在“构建时（build time）”把页面渲染成静态 HTML 文件，然后部署到 CDN/静态服务器。**

访问时：

+ 用户请求某个 URL
+ CDN 直接返回对应的 `.html`（以及静态资源 JS/CSS/图片）
+ 浏览器解析 HTML 即可展示内容  
（交互如果需要，再加载 JS 做增强：可以是全量 hydration，也可以是局部岛屿）

一句话：

**SSR 是“请求时渲染”，SSG 是“构建时渲染”。**

---

# 2）SSG 的完整运行流水线（你必须能讲清楚“发生了什么”）
以“文章站/商品展示页”为例：

## 2.1 构建阶段（Build time）
1. 构建系统启动（CI 或本地）：`npm run build`
2. 读取内容源（Markdown / CMS API / 数据库导出 / Git 仓库）
3. 生成路由列表（例如所有文章 slug：`/posts/a`、`/posts/b`）
4. 对每个路由执行渲染：
    - 运行页面组件（在 Node/构建环境）
    - 拉取对应数据（文章正文、作者信息）
    - 输出静态 HTML 文件（`/posts/a/index.html`）
5. 同时生成静态资源：JS/CSS、图片优化产物等（带 hash 指纹）
6. 输出构建产物目录（dist/out）

## 2.2 部署阶段（Deploy）
1. 把 dist 上传到 CDN/对象存储（S3、OSS、Cloudflare R2 等）
2. CDN 分发到边缘节点，配置缓存策略

## 2.3 访问阶段（Runtime）
1. 用户访问页面：CDN 直接吐 HTML（通常 TTFB 极低）
2. 浏览器立刻看到内容（LCP 很容易优秀）
3. 需要交互的部分再加载 JS（可选：全量 hydration / islands / 纯无 JS）

关键：**渲染发生在构建时，不在用户请求时。**  
这就是 SSG 快、便宜、稳定的根源。

---

# 3）SSG 为什么快？快在哪里？（本质优势）
## 3.1 SSG 的性能优势是“物理级”的
因为：

+ 不需要每个请求都在服务器算 HTML（没有 SSR 的“请求时计算”）
+ HTML 是静态文件，CDN 边缘直接返回（网络距离近、缓存命中高）
+ 静态资源天然适合长缓存（hash + immutable）

结果通常是：

+ **TTFB 极低**
+ **LCP 极好**
+ 源站压力几乎为零（甚至没有源站）

## 3.2 SSG 的稳定性也更强
+ 没有运行时渲染服务，就少了“渲染服务挂了就全站挂”的风险
+ 高并发访问时主要靠 CDN 扛（天生抗压）

---

# 4）SSG 的代价：它难在哪里？为什么不是所有站都 SSG
SSG 的核心矛盾是：

**页面在构建时就定型了，但真实世界的数据在不断变化。**

于是带来三类问题：

## 4.1 内容更新：如何让用户看到新内容？
+ 内容变了 → 你必须重新构建并部署（或者用 ISR/增量更新）
+ 内容更新频率越高，构建压力越大

## 4.2 页面规模：页面数量太多怎么办？
+ 10 万页面全量构建会慢到不可接受
+ 这催生了：增量构建、分批构建、按需生成（ISR / on-demand）

## 4.3 个性化：按用户变化怎么办？
+ SSG 输出的是公共 HTML
+ 如果页面强个性化（用户权益、推荐、订单），就不能纯 SSG  
解决只能是：
+ 客户端再拉私有数据（CSR 补）
+ 或边缘/服务器拼装（更复杂）
+ 或把个性化限定在小组件（islands）

---

# 5）SSG 的“正确使用姿势”：分清三类内容
这是你做架构决策最重要的一条。

## 5.1 公共且稳定的内容（最适合 SSG）
+ 文档、博客、产品介绍页、帮助中心
+ 公共商品信息（不含实时库存/价格波动）

## 5.2 公共但会变化的内容（SSG + 再生成）
+ 新闻、榜单、商品列表  
→ 用 ISR/定时重建/按需重建

## 5.3 私有个性化内容（不要强上 SSG）
+ 用户中心、订单、权限菜单  
→ CSR 或 SSR 更合理  
（或“主体 SSG + 个性化小岛”）

---

# 6）SSG + 交互：你必须理解“静态 HTML”与“JS 增强”的组合方式
SSG 并不等于“没有 JS”。它只是“HTML 是静态的”。

常见组合：

## 6.1 纯静态（0 JS）
+ 只有内容展示，靠 HTML/CSS  
优点：最快、最稳、最省钱  
适合：文档、说明页

## 6.2 SSG + 全量 hydration（静态首屏 + SPA 接管）
+ 首屏由静态 HTML 出
+ JS 加载后整站变成 SPA（后续导航 CSR）  
优点：首屏快 + SPA 体验  
代价：仍有 hydration 税（JS 体积）

## 6.3 SSG + Islands（强烈推荐的现代内容站形态）
+ 页面主体静态（正文、布局）
+ 只有评论/点赞/搜索等小区域加载 JS  
优点：**JS 极小，交互税最低**  
适合：媒体/营销/电商展示

你会发现：SSG 的“上限”很高，关键在于你怎么控制交互 JS 的范围。

---

# 7）SSG 的数据来源与“内容流水线”设计（架构层核心）
SSG 最大的工程挑战不是渲染，而是：**内容从哪里来、什么时候触发构建、如何预览与发布**。

## 7.1 内容来源（Content Source）
+ Git 仓库（Markdown）：最简单、版本化好
+ Headless CMS（Contentful、Strapi 等）：编辑友好
+ API 导出：从数据库导出静态快照

## 7.2 构建触发（Build Trigger）
+ Git push 触发构建（文档/博客常见）
+ CMS 发布触发 webhook → 触发构建
+ 定时构建（每天/每小时刷新榜单）

## 7.3 预览环境（Preview）
现代内容团队需要：

+ 草稿预览（不影响线上）
+ PR Preview（每个 PR 一个预览 URL）

如果你没有预览链路，内容生产会非常痛苦。

---

# 8）缓存策略：SSG 的甜点，但也最容易“发版错配”
SSG 通常这样配缓存：

## 8.1 静态资源（JS/CSS/图片）
+ 文件名带 hash
+ `Cache-Control: max-age=31536000, immutable`
+ CDN 长缓存

## 8.2 HTML（静态页面文件）
+ 可以缓存，但要考虑“更新时刻”
+ 常见策略：
    - HTML 短缓存（更稳）
    - 或 HTML 也长缓存，但配合版本化路径/刷新策略（更复杂）

**大坑：**  
如果你把 HTML 也长缓存，而 HTML 引用的 JS/CSS 版本变了，可能出现：

+ 旧 HTML 指向不存在的新资源 → 404 → 白屏

解决原则：

+ 静态资源一定版本化（hash）
+ HTML 的缓存策略要与你的发布策略匹配（要么短缓存，要么严格版本化路径）

---

# 9）SSG 常见坑清单（提前知道能省一年）
1. **页面数量爆炸导致构建时间不可控**  
→ 需要增量构建/ISR/分批构建策略
2. **把动态数据硬塞进构建期**  
→ 价格/库存这类实时数据不适合纯 SSG，要做客户端补或边缘拼装
3. **构建期依赖外部 API 不稳定**  
→ 构建失败、发布中断（要有重试、缓存、降级数据源）
4. **把太多数据序列化进 HTML**  
→ HTML 变巨大，反而拖慢首屏（要控制 payload）
5. **预览/发布链路缺失**  
→ 内容团队无法高效协作，回滚困难
6. **缓存策略不匹配导致白屏**  
→ HTML 与静态资源版本错配（发布策略必须严谨）

---

# 10）如何验证你做的 SSG “真的正确”（证据闭环）
你可以用这些方法确认：

## 10.1 功能验证
+ 断网/禁 JS：页面是否仍能显示核心内容（SSG 的本质价值）
+ View Source：正文是否在 HTML 源码里（SEO 也会吃到）

## 10.2 性能验证
+ Network：TTFB 是否显著降低（CDN 命中）
+ Lighthouse：LCP 是否优秀
+ 资源瀑布：是否没有“请求时渲染”导致的等待

## 10.3 成本与稳定性验证
+ 源站 QPS 接近 0（主要由 CDN 扛）
+ 高峰访问是否几乎不影响系统（因为都是静态）

---

# 11）SSG 与 SSR/CSR/ISR 的边界：你怎么做选择
你可以用一句话来决策：

+ **内容稳定且公共 → SSG**
+ **内容公共但会更新 → SSG + ISR/重建**
+ **内容强个性化/实时性强 → SSR 或 CSR**
+ **内容为主 + 少量交互 → SSG + Islands（现代最优形态之一）**

---

# 12）一个“SSG 页面架构账本”示例（你以后可以照抄）
以“文章详情页”为例：

1. HTML 生成：SSG（构建时生成每篇文章 HTML）
2. 数据来源：Markdown/CMS（构建时拉取文章、作者信息）
3. 交互策略：正文静态；评论/点赞作为 Islands 客户端加载
4. 缓存策略：JS/CSS hash 长缓存；HTML 短缓存或按发布策略刷新  
验证：TTFB<50ms（CDN），LCP 优秀，禁 JS 仍可读正文

---

## 如果你愿意，我可以继续把 1.4 ISR（增量静态再生）讲到同样深度，并且告诉你：
+ SSG 规模化怎么做（10 万页面如何构建）
+ CMS 发布触发按需重建怎么设计
+ 如何避免“构建爆炸”和“缓存错配白屏”

你也可以告诉我：你更关心 SSG 在 **文档/博客**、还是 **电商/内容站** 的落地，我可以按场景给你一套“可直接照做”的架构方案。

