---

title: "为什么说 SSR 是架构决策？"
date: "2025-12-26"
slug: "ssr"
category: "frontend"
tags: ["isr", "incremental-static-regeneration", "nextjs", "ssg", "ssr", "cdn"]
excerpt: "把 SSR 讲到你能用它做架构决策、能排障、能优化的程度：理解它为什么快/慢、数据与缓存怎么设计、Hydration 税怎么减、什么时候该用/不该用、常见坑与验证手段。"
draft: false
featured: false
pinned: false
---
下面我把 **SSR（Server-Side Rendering，服务端渲染）**讲到“你能用它做架构决策、能排障、能优化”的程度。结构会非常系统：**它是什么 → 浏览器与服务器发生了什么 → 为什么快/慢 → 数据与缓存怎么设计 → Hydration 税怎么减 → 什么时候该用/不该用 → 常见坑与验证手段**。

---

# 1）SSR 到底是什么（架构定义）
**SSR = 页面首次请求时，由服务器把 UI 渲染成 HTML 返回给浏览器。**

关键点：

+ 服务器返回的 HTML **已经包含首屏内容**（不是空壳）
+ 浏览器拿到 HTML 后能立刻“看见内容”
+ 但要变成“可交互的 React 应用”，还需要客户端加载 JS 并进行 **Hydration（水合/注水接管）**

SSR ≠ 纯静态 HTML  
SSR = “服务端先把内容画出来” + “客户端再接管交互”

---

# 2）SSR 的完整运行流水线（你必须能把每一步讲清楚）
以 React/Next 类框架为例（概念通用）：

## 2.1 首次请求：从浏览器到服务器
1. 浏览器请求 `GET /products/123`
2. 服务端路由匹配到页面组件（例如 ProductPage）
3. 服务端获取数据（商品详情、价格、库存、推荐等）
4. 服务端执行渲染：把组件树渲染成 HTML 字符串/流
5. 服务端返回 HTML（可能包含序列化数据，供客户端复用）
6. 浏览器解析 HTML，立刻绘制出首屏内容（**此时“可见”但不一定“可交互”**）

## 2.2 客户端接管：Hydration（交互税）
1. 浏览器下载 JS（框架 runtime + 页面代码 + 依赖）
2. React 在客户端“用同一棵组件树”对齐已有 HTML
3. 绑定事件监听、恢复状态、建立内部 Fiber 结构
4. Hydration 完成后，页面才完全可交互

SSR 的性能画像通常是：  
**首屏内容更早出现（LCP 更好）**，但 **可交互时间可能被 hydration 拖住（INP/TTI 风险）**

---

# 3）SSR 为什么快？它快在哪些指标上？
SSR“快”的核心是：**关键内容不等 JS 执行也能出现**。

## 3.1 SSR 主要提升的体验
+ **首屏可见更早**：HTML 已经有内容，浏览器解析即渲染
+ **SEO 更自然**：爬虫直接抓 HTML 就有正文
+ **分享预览更稳**：OG tags、meta 可在服务端按页面生成

## 3.2 SSR 对性能指标的典型影响
+ **LCP 往往更好**：最大内容元素更早进入 DOM
+ **TTFB 往往更差或更不稳定**：服务器需要取数+渲染
+ **INP/交互响应可能变差**：hydration 很重时出现“看得见点不动”

你要把 SSR 理解成：用服务器算力换首屏可见性，但你要管理 hydration 税与服务器延迟。

---

# 4）SSR 的代价：它慢在哪里？为什么复杂？
SSR 的复杂不是“会写 renderToString”，而是这些系统问题：

## 4.1 服务端成本与延迟
+ 每个请求都要执行渲染（CPU）
+ 每个请求可能还要取数据（IO）
+ 高并发下需要：
    - 缓存
    - 连接池
    - 限流降级
    - 监控与扩容

## 4.2 数据瀑布（SSR 最常见的“TTFB 杀手”）
如果服务端渲染过程中数据获取是串行的：

+ A 数据回来才能请求 B
+ B 回来才能渲染 C  
那 **TTFB 会被拖爆**。

解决方向：

+ 路由级并行 loader
+ BFF 聚合一次返回
+ Streaming SSR + Suspense（先出骨架/关键块）

## 4.3 Hydration（交互税）
SSR 的 HTML 只是“静态内容”，交互需要 hydration：

+ 页面越大、组件越多、JS 越大 → hydration 越慢
+ hydration 期间主线程忙 → 用户输入响应差（INP）

---

# 5）SSR 架构最关键的 3 个设计题
你真正要掌握 SSR，不是 API，是这三题：

## 5.1 数据：在哪拿？拿多少？怎么避免瀑布？
### 常见正确形态
+ **路由级数据加载**：进入页面先把该页面需要的数据并行拿齐
+ **服务端聚合**：通过 BFF 把多个后端请求合并成 1 次
+ **复用数据**：服务端拿到的数据序列化给客户端，避免客户端再请求一遍（不然“SSR 一次 + 客户端又请求一次”会浪费）

### 你必须注意的坑
+ 序列化体积过大：把巨量数据塞进 HTML 反而拖慢首屏
+ 把私密信息序列化到客户端：安全事故

## 5.2 缓存：SSR 能不能缓存？怎么缓存才不翻车？
SSR 并不是一定“每次都算”，很多 SSR 页面可以缓存。

关键在于：**缓存键**与**个性化程度**。

+ 公共内容（文章、商品）：适合 CDN/Edge 缓存 HTML
+ 按地区/语言变化：缓存键要包含地区/语言
+ 按用户变化（登录态/权益）：通常不适合公共缓存；可能需要“私有缓存”或“ESI/边缘拼装”

你要掌握的缓存原则：

+ 静态资源：hash + 长缓存
+ HTML：通常短缓存或按策略缓存（SSR/ISR/Edge）

## 5.3 交互：如何减 hydration 税？
核心目标：**减少需要在客户端水合的东西**。

常见策略（按效果从大到小）：

1. **减少客户端 JS**：大库懒加载、去掉不必要依赖
2. **局部水合（Islands）**：只让少数交互组件水合
3. **延迟水合**：首屏非关键交互（比如评论）滚动到再水合
4. **把更多逻辑留在服务端**：让页面更“内容化”

---

# 6）SSR 的不同形态（你要分得清，不然会混乱）
## 6.1 SSR（每次请求渲染）
+ 最实时，但成本最大
+ 适合强实时个性化

## 6.2 SSR + 缓存（接近静态）
+ 热门公共页面缓存命中率高
+ 成本下降，体验仍好
+ 难点：缓存失效与 Vary 设计

## 6.3 Streaming SSR（流式 SSR）
+ 先把能渲染的部分吐出来，晚点补剩下的
+ 适合数据依赖复杂的页面
+ 配合 Suspense 能显著改善“首屏可见”

## 6.4 SSR + Islands（混合）
+ 主体 SSR 出 HTML
+ 交互模块 CSR/岛屿加载
+ 是现代内容型站点的高性价比解法

---

# 7）SSR 什么时候该用？什么时候不该用？（决策表）
## 7.1 强烈适合 SSR 的场景
+ SEO 关键（内容站、商品详情、落地页）
+ 首屏必须非常快“见到内容”
+ 分享预览要准确（动态 meta）
+ 需要服务端鉴权/重定向（登录态强相关页面）

## 7.2 不一定适合 SSR 的场景
+ 后台系统/强交互 App（CSR 更自然）
+ 页面个性化极强但无法有效缓存（成本高）
+ 服务端资源紧张、业务高峰波动大
+ 你无法管理 hydration 税（页面巨大、JS 很重）

## 7.3 常见折中（非常实用）
+ 首页/详情 SSR，后台 CSR
+ 列表 ISR，详情 SSR
+ 主体 SSR，评论/推荐 Islands

---

# 8）SSR 最常见的“翻车点”与排查
## 8.1 Hydration mismatch（最典型）
现象：

+ 控制台警告：服务端 HTML 与客户端渲染不一致
+ 页面闪动、事件不绑定、局部错乱

常见原因：

+ render 中使用 `Date.now()` / `Math.random()`（服务端与客户端值不同）
+ 依赖 `window`/`document`（服务端没有）
+ 读取本地时区/语言导致差异
+ 条件渲染依赖“仅客户端可知的信息”（比如 localStorage）

解决思路：

+ 把不确定值延后到 effect 中
+ 用 “客户端专用组件” 或在客户端挂载后再渲染
+ 确保服务端与客户端初始状态一致

## 8.2 TTFB 高
原因：

+ 服务端取数串行瀑布
+ 后端接口慢/不稳定
+ SSR 服务器 CPU 忙（渲染太重）

排查：

+ 服务端打点：路由匹配、取数耗时、渲染耗时
+ APM/日志：慢请求链路
+ 缓存命中率检查

## 8.3 “看得见但点不动”（INP 差）
原因：

+ JS 太大
+ hydration 太重
+ 首屏渲染/计算太多（大列表、复杂图表）

解决：

+ 代码分割、延迟加载
+ Islands/局部水合
+ 虚拟列表、减少首屏组件数量
+ 低优先级更新延后（并发特性/transition 思路）

---

# 9）SSR 如何验证“我做对了”（证据闭环）
你必须能用工具证明 SSR 的收益与代价：

## 9.1 看 HTML 是否真的“有内容”
+ View Source：正文是否在 HTML 里
+ 禁用 JS：页面是否仍能展示核心内容（这是 SSR 的价值体现）

## 9.2 看性能指标结构
+ Network：TTFB 是否上升？HTML 是否可缓存？
+ Performance：hydration 期间是否大量长任务？
+ LCP：是否改善？
+ INP：是否变差？是否需要减水合？

## 9.3 看缓存与成本
+ CDN 命中率、源站 QPS、渲染耗时分布
+ 热点页面是否被有效缓存，避免 SSR 被打爆

---

# 10）一句话总结 SSR 的“正确姿势”
**SSR 用服务器先把首屏内容送达，换取更好的可见性与 SEO；但你必须用并行取数/缓存/流式/局部水合来控制 TTFB 与 hydration 税，否则 SSR 只是把问题从客户端搬到服务端。**

---

如果你愿意，我可以用一个具体页面（例如“商品详情页”或“文章详情页”）给你做一份 SSR 的**架构账本**：

+ 服务端取数怎么并行？
+ 哪些数据应该序列化给客户端？
+ 哪些部分做 Islands？
+ HTML/CDN 缓存键怎么设计？
+ 怎么验证 LCP/INP/TTFB 的变化？

你告诉我页面类型（内容/电商/登录页/列表页）和是否有登录态个性化，我就按你的场景把 SSR 方案落到可执行级别。

