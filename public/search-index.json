[
  {
    "slug": "draft-experiment",
    "title": "Draft: Experimental Typography",
    "excerpt": "",
    "headings": [],
    "contentText": "This is a draft note. It should never appear in production lists or detail pages unless drafts are explicitly enabled for development."
  },
  {
    "slug": "quiet-transitions",
    "title": "Quiet Transitions",
    "excerpt": "",
    "headings": [],
    "contentText": "Quiet transitions reduce fatigue. The content layer should avoid scaling or dramatic movement; focus instead on a subtle dimming and a short, ink like wash. We treat motion as an editorial device. The system should be felt more than seen, prioritizing continuity and readability over decoration."
  },
  {
    "slug": "paper-catalog",
    "title": "Catalog Lists and Editorial Rhythm",
    "excerpt": "Catalog lists are the backbone of discovery. This note tracks spacing, rules, and scanability.",
    "headings": [],
    "contentText": "Catalog lists should feel like a magazine index: quiet, structured, and easy to scan. Titles carry the emphasis while metadata sits in a lighter voice. We avoid heavy cards and rely on thin rules, soft hover emphasis, and tight vertical rhythm. The spacing system is tuned for both mobile and wide viewports."
  },
  {
    "slug": "design-tokens",
    "title": "Design Tokens: Warm Paper Set",
    "excerpt": "",
    "headings": [],
    "contentText": "The design system is anchored by a warm paper palette and two primary typefaces. UI elements stay on Inter while long form reading uses a serif that matches the editorial tone. Tokens are mapped directly to shadcn variables so every component inherits the same background, border, and ring colors without custom overrides."
  },
  {
    "slug": "editorial-motion",
    "title": "Editorial Motion Notes",
    "excerpt": "Building a quiet motion system that feels like a magazine turning page by page.",
    "headings": [],
    "contentText": "Editorial Motion Notes Motion should feel like a breath, not a spectacle. The transition system uses three layers: content, film, and ink. Each layer has a single purpose and stays within strict limits for blur and opacity. The shared element system is the continuity anchor. Titles and covers are tracked by layout IDs so the page change feels like a continuous layout rather than a cut. Future adjustments will favor less movement, smaller easing curves, and an even lighter hand on the ink layer."
  },
  {
    "slug": "isr",
    "title": "ISR（Incremental Static Regeneration）彻底讲透：架构、策略与实战避坑",
    "excerpt": "把 ISR 讲到你真的会用、会选、会排坑的程度：理解它如何把 SSG 的极致快与 SSR 的可更新结合起来，构成可控的缓存+再生架构。",
    "headings": [
      "1）ISR 到底是什么（架构定义与心智模型）",
      "1.1 ISR 在回答哪两个矛盾",
      "1.2 ISR 的本质结构：SWR 思想",
      "2）ISR 的完整运行流水线（你必须能讲清楚每一步）",
      "2.1 首次生成（预生成或首次访问生成）",
      "2.2 正常命中缓存（在 60 秒内）",
      "2.3 缓存过期（超过 60 秒）",
      "2.4 再生成完成后",
      "3）ISR 为什么好用？它解决的核心问题是什么？",
      "3.1 “快”和“新”不必二选一",
      "3.2 构建规模化：解决“页面太多无法全量构建”",
      "3.3 对源站压力更可控",
      "4）ISR 的两种核心模式：定时再生 vs 按需再生（on-demand）",
      "4.1 定时再生（Time-based Revalidate）",
      "4.2 按需再生（On-demand Revalidate）",
      "5）ISR 的关键设计题（这是你真正要掌握的）",
      "5.1 revalidate 该设多少？（更新窗口怎么选）",
      "5.2 缓存键（Cache Key）怎么设计？",
      "5.3 再生成时的并发与锁（避免“惊群”）",
      "5.4 再生成失败怎么办？",
      "5.5 数据一致性：页面里哪些该静态，哪些必须实时？",
      "6）ISR 与 SSR/SSG/CSR 的关系（你如何做选择）",
      "7）ISR 的常见落地架构（你应该能画出来）",
      "8）ISR 常见坑清单（非常实战）",
      "9）如何验证 ISR 是否正确（证据闭环）",
      "性能",
      "新鲜度",
      "稳定性",
      "成本",
      "10）一个“ISR 页面架构账本”示例（你以后可以照抄）",
      "11）你真正“懂 ISR”的标志：你能回答这些问题"
    ],
    "contentText": "下面把 ISR（Incremental Static Regeneration，增量静态再生） 讲到你“真的会用、会选、会排坑”的程度。你会看到 ISR 不是一个“功能”，而是一套 缓存 + 再生成 的架构：把 SSG 的极致快 和 SSR 的可更新 揉在一起，并且把“更新”变成可控策略。 先给你一句最核心的定义： ISR = 静态 HTML + 缓存（CDN/边缘） + 过期/触发后在后台再生成并更新缓存（常见是 SWR：stale while revalidate） 1）ISR 到底是什么（架构定义与心智模型） 1.1 ISR 在回答哪两个矛盾 SSG 的矛盾： 静态 HTML 非常快 但内容更新要重建全站/全量构建（慢、贵、复杂） SSR 的矛盾： 内容实时 但每次请求都要算 HTML（贵、压力大、延迟更不稳） ISR 的目标： 大多数请求像 SSG 一样快（直接返回静态 HTML） 内容需要更新时，又能像 SSR 一样“重新生成” 并且生成发生在 后台 ，不把所有用户都拖慢 1.2 ISR 的本质结构：SWR 思想 典型 ISR 工作方式是 Stale While Revalidate（过期可用 + 后台更新） ： 页面有一个“再生周期/失效时间（revalidate）” 在周期内：直接返回缓存的静态 HTML（快） 超过周期后： 先返回旧的 HTML（stale）给当前用户 （仍快） 同时后台触发“再生成”（revalidate）并写回缓存 下一位用户访问就得到新的 HTML 这就是为什么 ISR 既快又能更新： 用户体验优先，更新在后台完成。 2）ISR 的完整运行流水线（你必须能讲清楚每一步） 以页面 /news/123 为例，设定 revalidate = 60s： 2.1 首次生成（预生成或首次访问生成） 构建期可能已经生成 /news/123.html（像 SSG） 或者没有生成，首次访问时生成（按框架能力：fallback / on demand） 生成后： HTML 写入存储（构建产物或边缘缓存） CDN/边缘开始缓存这个 HTML 2.2 正常命中缓存（在 60 秒内） 用户访问： CDN/边缘直接返回静态 HTML（TTFB 极低） 不触发再生成 2.3 缓存过期（超过 60 秒） 第一个来访用户触发“过期窗口”： 仍返回旧 HTML（快） 同时后台触发再生成： 服务端取最新数据 渲染出新 HTML 写回缓存（替换旧版本） 2.4 再生成完成后 后续用户： 命中新 HTML（变新了，但仍是静态级速度） 3）ISR 为什么好用？它解决的核心问题是什么？ 3.1 “快”和“新”不必二选一 快 ：大多数请求都走缓存静态 HTML（接近 SSG） 新 ：内容会在设定时间窗内自动更新（不必全量重建） 稳 ：再生成失败时可以继续返回旧页面（stale 兜底） 3.2 构建规模化：解决“页面太多无法全量构建” 如果你有 10 万个详情页： 纯 SSG：全量构建会爆 ISR：只生成热门页或按需生成，冷门页访问到才生成（按框架实现） 3.3 对源站压力更可控 SSR：每次请求都压力 ISR：只有“过期触发”或“按需触发”时才压力 4）ISR 的两种核心模式：定时再生 vs 按需再生（on demand） 4.1 定时再生（Time based Revalidate） 每个页面设定 revalidate = X 秒/分钟 过期后后台更新 适合： 更新频率可预估：新闻列表、活动页、商品信息（不含实时价格/库存） 允许最多 X 时间的陈旧 优点： 简单可靠 缺点： 无法做到“内容发布立即更新”，需要等到过期窗口或主动触发 4.2 按需再生（On demand Revalidate） CMS 发布内容后发 webhook → 触发某个页面（或某类页面）立即再生 或后台管理操作后触发相关页面再生 适合： “编辑一发布就要生效”的内容站 精准更新：只刷新受影响的页面 优点： 更新更及时、无需等待 TTL 缺点： 需要建立触发链路（webhook、安全校验、去重、队列） 现实项目里通常是两者组合： 定时再生兜底 + 按需再生确保关键更新立即生效 5）ISR 的关键设计题（这是你真正要掌握的） 5.1 revalidate 该设多少？（更新窗口怎么选） 这是“架构与业务”的交汇点： 内容更新很少（文档）：小时级/天级 新闻/榜单：分钟级 商品基础信息：分钟级/小时级 价格/库存：通常不适合进 HTML（应该客户端实时拉或单独接口） 决策原则： 1. 用户能接受的最大陈旧时间 是多少？ 2. 源站成本 能承受多少再生频率？ 3. 页面重要性 不同，revalidate 应不同（热门页更短，冷门页更长） 5.2 缓存键（Cache Key）怎么设计？ 缓存键决定命中率与正确性，尤其是： 语言（Accept Language / locale） 地区/货币 设备（移动/桌面若差异很大） 登录态/权限（通常不要把用户态放进 ISR HTML） 原则： ISR 页面尽量保持“公共可缓存” 个性化放到客户端 islands 或私有接口 5.3 再生成时的并发与锁（避免“惊群”） 当一个热门页面过期，可能有大量请求同时到达： 如果每个请求都触发再生成 → 源站被打爆（thundering herd） 正确做法（框架或你自己要提供）： 单飞机制（single flight） ：同一页面同一时间只允许一个再生任务 其他请求继续返回 stale，或等待同一个再生结果（看策略） 5.4 再生成失败怎么办？ ISR 的稳定性关键在“失败策略”： 常见策略： 失败继续返回旧页面 （stale while error） 记录失败次数与告警 限制重试频率，避免死循环打爆后端 5.5 数据一致性：页面里哪些该静态，哪些必须实时？ 这是 ISR 成败的核心： 适合静态/可接受延迟 ：正文、图片、简介、评分概览 不适合静态 ：实时库存、实时价格、强个性化推荐、用户私有信息 常见混合方案： HTML 用 ISR（快） 关键实时信息用客户端接口补（准） 交互模块用 islands（轻 JS） 6）ISR 与 SSR/SSG/CSR 的关系（你如何做选择） SSG ：构建时一次生成，更新靠重建（最快、但更新不灵活） ISR ：静态为主，后台增量更新（快 + 可更新） SSR ：请求时渲染（最实时/最个性化，但成本与不确定性高） CSR ：客户端渲染（强交互应用，首屏依赖 JS） 适合 ISR 的情况： 页面内容是公共的 更新频率中等（分钟～小时） 需要极好首屏与成本控制 页面数量大（无法全量构建） 7）ISR 的常见落地架构（你应该能画出来） 一个典型 ISR 站点（内容/电商展示）通常长这样： CDN：缓存 HTML（ISR）与静态资源（hash 长缓存） 再生服务：在过期/触发时运行渲染（可能在应用服务器或边缘） 内容来源：CMS / 数据服务 客户端：只做少量交互 islands + 实时数据补充 你在架构上要明确： HTML 谁负责生成？ 生成结果存到哪里（边缘缓存/对象存储/内存）？ 过期策略如何定义？ 再生失败如何兜底？ 触发链路如何保证安全与去重？ 8）ISR 常见坑清单（非常实战） 1. 把强个性化内容放进 ISR HTML 导致无法缓存、或者缓存错给别人（严重事故） 解决：个性化用客户端或私有 SSR，不进公共缓存 2. revalidate 设太短 页面频繁再生，源站压力大、成本暴涨 解决：分层（热门短、冷门长），配 single flight 3. 过期惊群 热门页一过期就被打爆 解决：single flight + stale while revalidate 4. 再生失败导致页面“永远不更新” 没有告警、没有重试策略 解决：失败监控、错误兜底、告警与限流 5. 缓存键设计不当 语言/地区/设备没进缓存键 → 用户看到错版本 Cookie 进缓存键 → 命中率暴跌 解决：明确 Vary 与缓存键策略 6. 更新发布链路缺失 编辑发布后要等很久才更新 解决：on demand revalidate + webhook 9）如何验证 ISR 是否正确（证据闭环） 你要从 4 个角度验证： 性能 绝大多数请求 TTFB 极低（CDN HIT） LCP 优秀（HTML 直接有内容） 新鲜度 内容更新后在设定窗口内可见 或 on demand 触发后几秒内生效 稳定性 后端服务短暂挂了，页面仍可打开（stale 兜底） 再生失败有告警与记录 成本 源站 QPS 不随访问线性增长（只有再生时增加） 再生频率可控（按页面热度分级） 10）一个“ISR 页面架构账本”示例（你以后可以照抄） 以“新闻详情页 /news/:id”为例： 1. HTML 生成：ISR，revalidate=300s（5 分钟） 2. 数据来源：CMS API（构建/再生时拉正文与图片） 3. 交互策略：评论/点赞 islands 客户端加载；实时热度单独接口补 4. 缓存：静态资源 hash 长缓存；HTML CDN 缓存，按 locale vary 5. 更新：CMS 发布触发 on demand revalidate（立即更新），TTL 作为兜底 6. 失败：再生失败继续返回旧 HTML，并告警 11）你真正“懂 ISR”的标志：你能回答这些问题 这个页面允许陈旧多久？revalidate 该设多少？ 哪些内容可以静态，哪些必须实时？ 缓存键怎么设计才能既正确又高命中？ 过期时大量请求怎么避免惊群？ 再生失败怎么办？怎么告警？ CMS 发布后如何立即更新？on demand 链路怎么做安全校验？ 如果你愿意，我可以把 ISR 再往下“落到手能做”的层面： 你告诉我一个你熟悉的页面类型（ 文章、商品详情、列表、活动页 任选），我给你： revalidate 建议值 （按业务更新频率） 哪些字段进 HTML、哪些字段客户端补 缓存键/Vary 设计 on demand revalidate 的触发链路设计（含安全与去重） 惊群与失败兜底策略 并告诉你如何用 DevTools/日志验证命中与更新是否符合预期。"
  }
]